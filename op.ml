
(*
	RunRadis: Run RadiScript screens
	Copyright (C) 2009, 2010, 2011  James Hahn

	This file is part of RunRadis.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *)

open Fieldindex;;

exception Internal_error of string;;

exception Syntax_error of string;;

(*
 * Operations generated by the parser.
 *)

type op =
		Screens		of op list
	|	ScreenDef	of string*op
	|	Actions		of op*op
	|	Uses		of string list
	|	Deblank		of string list
	|	Keep		of op
	|	Sort		of op list
	|	Top			of float*bool*bool		(* amount, %, tied *)
	|	Create		of string*op
	|	Replace		of string*op*op
	|	Set			of string*op
	|	Unique		of string*bool			(* name, first *)
	|	AddScreen	of string*int*int*int*bool		(* name, beg-rank, end-rank, beg-score, pad *)
	|	Sos			of int
	|	Overlap
	|	Pad			of int*(string*int) list	(* count, [(screen,count)] *)
	|	Print		of op list
	|	Ascending	of string
	|	Descending	of string
	|	Eq			of op*op
	|	Neq			of op*op
	|	Lt			of op*op
	|	Gt			of op*op
	|	Le			of op*op
	|	Ge			of op*op
	|	Add			of op*op
	|	Sub			of op*op
	|	Mult		of op*op
	|	Div			of op*op
	|	Pow			of op*op
	|	Neg			of op
	|	Sym			of string
	|	StrCon		of string
	|	NumCon		of float
	|	CurTime
	|	True
	|	False
	|	Not			of op
	|	Or			of op*op
	|	And			of op*op
	|	If			of op*op*op
	|	Average		of string
	|	Median		of string
	|	Sum			of string
	|	Count		of string
	|	Min			of op*op
	|	Max			of op*op
	|	Sign		of op
	|	Abs			of op
	|	Length		of op
	|	Left		of op*op
	|	Right		of op*op
	|	Mid			of op*op*op
	|	Match		of op*string*bool
	|	Concat		of op*op

	(* these are not generated by the parser, but are used internally *)

	|	Null		of string
	|	Exists		of string

	(* these wrap an op to identity its data type *)

	|	Num			of op
	|	Date		of op
	|	Bool		of op
	|	Str			of op
	|	Any			of op
;;


let non_const = Not(CurTime);;
	(* non-constant value that cannot be optimized away *)


(*
 * A table of temporary variables is created for each screen that is
 * compiled.  If a given temp variable is assigned a constant value, then
 * when it is subsequently referenced, the constant is used rather than
 * re-computing the value.
 *
 * Likewise for the global temporary variables.
 *)

let tempvars = ref (Hashtbl.create 111);;
let globvars = ref (Hashtbl.create 111);;


(*
 * Add a variable and its value to the temp table.  Removes it from the
 * other temp table
 *)

let add_temp_val varnm value =
	Hashtbl.replace !tempvars varnm value;
	Hashtbl.remove !globvars varnm;;

let add_glob_val varnm value =
	Hashtbl.replace !globvars varnm value;
	Hashtbl.remove !tempvars varnm;;


(*
 * Add a variable to the temp table.  Removes it from the
 * other temp table
 *)

let add_temp varnm =
	Hashtbl.replace !tempvars varnm non_const;
	Hashtbl.remove !globvars varnm;;

let add_glob varnm =
	Hashtbl.replace !globvars varnm non_const;
	Hashtbl.remove !tempvars varnm;;


(*
 * Convert all variables to non-const so they cannot be optimized away
 *)

let de_opt_const () =
	let de_const tbl =
		let keys = Hashtbl.fold (fun k v lst -> k::lst) tbl [] in
		List.iter (function k -> Hashtbl.replace tbl k non_const) keys
	in
	de_const !tempvars;
	de_const !globvars;;



(*
 * Find a temp variable's value in temp or global temp table
 *)

let find_any_temp varnm =
	try
		Hashtbl.find !tempvars varnm
	with Not_found ->
		Hashtbl.find !globvars varnm;;


(*
 * Save the temp table(s) and create a new one for use by the new screen that
 * is to be compiled
 *)

let save_temp () =
	let t = !tempvars in
	let g = !globvars in
	tempvars := Hashtbl.create 111;
	globvars := Hashtbl.create 111;
	add_temp_val rank_var_nm non_const;
	add_temp_val tied_rank_var_nm non_const;
	(t,g);;


(*
 * Create a new temp table, discarding previous changes
 *)

let recreate_temp () = ignore(save_temp ());;


(*
 * Restore the temp table back to its old contents
 *)

let restore_temp (t,g) =
	tempvars := t;
	globvars := g;;


(*
 * Maps a variable name to a symbol.  If the variable appears within the
 * temp table, then a TempVar is returned, otherwise a Var is returned
 *)

let mapname varnm =
	if Hashtbl.mem !tempvars varnm then
		TempVar varnm
	else if Hashtbl.mem !globvars varnm then
		GlobVar varnm
	else
		Var varnm;;


(*
 * Removes duplicates from a list.  Preserves the original order
 *)

let remove_dups values =
	let h = Hashtbl.create 11 in
	let addit lst a =
		if Hashtbl.mem h a then lst
		else
			begin
				Hashtbl.add h a 0;
				a::lst
			end
	in
	List.rev (List.fold_left addit [] values);;


(*
 * Takes a list of items and sticks them into a right-sided binary tree.
 * For instance:
 *
 *		opify (fun x y -> And(x,y)) [a;b;c;d]
 *
 * would yield:
 *		And(a, And(b, And(c,d)))
 *)

let opify fop lst =
	let revop x y = fop y x in
	let lr = List.rev lst in
	let h = List.hd lr in
	let t = List.tl lr in
	List.fold_left revop h t;;


(*
 * Optimize an op.  Recursively optimizes all of its sub-ops.
 *
 * Note: this must be called AFTER typify, because it assumes that
 * expressions are not yet wrapped in a type
 *)

let rec optimiz p =
	let q =			(* optimize subops *)
		match p with
			Screens(a) -> Screens(List.map optimiz a)
		|	ScreenDef(a,b) -> ScreenDef(a, optimiz b)
		|	Actions(a,b) ->
				(* force a to be optimized before b *)
				let a2 = optimiz a in
				let b2 = optimiz b in
				Actions(a2, b2)
		|	Uses(a) -> Uses(remove_dups a)
		|	Deblank(a) -> Deblank(remove_dups a)
		|	Keep(a) -> Keep(optimiz a)
		|	Create(a,b) -> Create(a, optimiz b)
		|	Replace(a,b,c) -> Replace(a, optimiz b, optimiz c)
		|	Set(a,b) -> Set(a, optimiz b)
		|	Print(a) -> Print(List.map optimiz a)
		|	AddScreen(a,b,c,d,e) ->
				begin
					de_opt_const ();
					add_temp (var_name "Total Score");
					add_temp (var_name "Screen Rank");
					add_temp (var_name "Pad");
					add_temp (var_name "Combo");
					add_temp (var_name "Max");
					p
				end
		|	Eq(a,b) -> Eq(optimiz a, optimiz b)
		|	Neq(a,b) -> Neq(optimiz a, optimiz b)
		|	Lt(a,b) -> Lt(optimiz a, optimiz b)
		|	Gt(a,b) -> Gt(optimiz a, optimiz b)
		|	Le(a,b) -> Le(optimiz a, optimiz b)
		|	Ge(a,b) -> Ge(optimiz a, optimiz b)
		|	Add(a,b) -> Add(optimiz a, optimiz b)
		|	Sub(a,b) -> Sub(optimiz a, optimiz b)
		|	Mult(a,b) -> Mult(optimiz a, optimiz b)
		|	Div(a,b) -> Div(optimiz a, optimiz b)
		|	Pow(a,b) -> Pow(optimiz a, optimiz b)
		|	Neg(a) -> Neg(optimiz a)
		|	Not(a) -> Not(optimiz a)
		|	Or(a,b) -> Or(optimiz a, optimiz b)
		|	And(a,b) -> And(optimiz a, optimiz b)
		|	If(a,b,c) -> If(optimiz a, optimiz b, optimiz c)
		|	Min(a,b) -> Min(optimiz a, optimiz b)
		|	Max(a,b) -> Max(optimiz a, optimiz b)
		|	Sign(a) -> Sign(optimiz a)
		|	Abs(a) -> Abs(optimiz a)
		|	Length(a) -> Length(optimiz a)
		|	Left(a,b) -> Left(optimiz a, optimiz b)
		|	Right(a,b) -> Right(optimiz a, optimiz b)
		|	Mid(a,b,c) -> Mid(optimiz a, optimiz b, optimiz c)
		|	Match(a,b,c) -> Match(optimiz a, b, c)
		|	Concat(a,b) -> Concat(optimiz a, optimiz b)
		|	_ -> p		(* no sub-ops to optimize - leave it as is *)
	in
	let rec optop p =			(* optimize the top level *)
		match p with

			Actions(Actions(a,b),c) -> optop (Actions(a,optop (Actions(b,c))))
				(* move sub-actions from left side to right side;
						tail-recursion can take better advantage of this *)

			(* combine "Uses", removing duplicates *)
		|	Actions(Uses(a), Uses(b)) -> Uses(remove_dups (a @ b))
		|	Actions(Uses(a), Actions(Uses(b),c)) ->
				Actions(Uses(remove_dups (a @ b)), c)

			(* combine "Deblank", removing duplicates *)
		|	Actions(Deblank(a), Deblank(b)) -> Deblank(remove_dups (a @ b))
		|	Actions(Deblank(a), Actions(Deblank(b),c)) ->
				Actions(Deblank(remove_dups (a @ b)), c)

			(* combine adjacent Keep's with And *)
		|	Actions(Keep(a), Keep(b)) -> Keep(optop (And(a,b)))
		|	Actions(Keep(a), Actions(Keep(b),c)) ->
				Actions(Keep(optop (And(a,b))), c)

		|	Create(a,b) ->
				begin
					add_temp_val a b;
					p
				end

		|	Replace(a,b,c) ->
				begin
					add_temp_val a non_const;
					p
				end

		|	Set(a,b) ->
				begin
					add_glob_val a b;
					p
				end

			(* turn operations into constants, where possible *)
		|	Eq(NumCon(a), NumCon(b)) -> if a = b then True else False
		|	Neq(NumCon(a), NumCon(b)) -> if a <> b then True else False
		|	Lt(NumCon(a), NumCon(b)) -> if a < b then True else False
		|	Le(NumCon(a), NumCon(b)) -> if a <= b then True else False
		|	Gt(NumCon(a), NumCon(b)) -> if a > b then True else False
		|	Ge(NumCon(a), NumCon(b)) -> if a >= b then True else False
		|	Add(NumCon(a), NumCon(b)) -> NumCon(a +. b)
		|	Sub(NumCon(a), NumCon(b)) -> NumCon(a -. b)
		|	Mult(NumCon(a), NumCon(b)) -> NumCon(a *. b)
		|	Div(NumCon(a), NumCon(b)) -> NumCon(a /. b)
		|	Pow(NumCon(a), NumCon(b)) -> NumCon(a ** b)
		|	Neg(Neg(a)) -> a
		|	Neg(NumCon(a)) -> NumCon(~-.a)

		|	Eq(StrCon(a), StrCon(b)) -> if a = b then True else False
		|	Neq(StrCon(a), StrCon(b)) -> if a <> b then True else False
		|	Lt(StrCon(a), StrCon(b)) -> if a < b then True else False
		|	Le(StrCon(a), StrCon(b)) -> if a <= b then True else False
		|	Gt(StrCon(a), StrCon(b)) -> if a > b then True else False
		|	Ge(StrCon(a), StrCon(b)) -> if a >= b then True else False

		|	Eq(StrCon(""),Sym(a)) -> Null(a)
		|	Eq(Sym(a),StrCon("")) -> Null(a)

		|	Neq(StrCon(""),Sym(a)) -> Exists(a)
		|	Neq(Sym(a),StrCon("")) -> Exists(a)

		|	Eq(True,a) -> a
		|	Eq(a,True) -> a
		|	Eq(False,a) -> optop (Not(a))
		|	Eq(a,False) -> optop (Not(a))

		|	Neq(True,a) -> optop (Not(a))
		|	Neq(a,True) -> optop (Not(a))
		|	Neq(False,a) -> a
		|	Neq(a,False) -> a

		|	Lt(True,a) -> False
		|	Lt(a,True) -> optop (Not(a))
		|	Lt(False,a) -> a
		|	Lt(a,False) -> False

		|	Gt(True,a) -> optop (Not(a))
		|	Gt(a,True) -> False
		|	Gt(False,a) -> False
		|	Gt(a,False) -> a

		|	Le(True,a) -> a
		|	Le(a,True) -> True
		|	Le(False,a) -> True
		|	Le(a,False) -> optop (Not(a))

		|	Ge(True,a) -> True
		|	Ge(a,True) -> a
		|	Ge(False,a) -> optop (Not(a))
		|	Ge(a,False) -> True

			(* replace a symbol with its constant value if it appears within
							the temp table as a constant *)
		|	Sym(a) ->
				begin
					try
						let v = find_any_temp a in
						match v with
							True -> v
						|	False -> v
						|	NumCon(b) -> v
						|	StrCon(b) -> v
						|	_ -> p
					with Not_found -> p
				end

			(* push "Not" operators down *)
		|	Not(Or(a, b)) -> optop (And(optop (Not(a)), optop (Not(b))))
		|	Not(And(a, b)) -> optop (Or(optop (Not(a)), optop (Not(b))))
		|	Not(True) -> False
		|	Not(False) -> True
		|	Not(Not(a)) -> a
		|	Not(Eq(a,b)) -> Neq(a,b)
		|	Not(Neq(a,b)) -> Eq(a,b)
		|	Not(Lt(a,b)) -> Ge(a,b)
		|	Not(Le(a,b)) -> Gt(a,b)
		|	Not(Gt(a,b)) -> Le(a,b)
		|	Not(Ge(a,b)) -> Lt(a,b)
		|	Not(Null(a)) -> Exists(a)
		|	Not(Exists(a)) -> Null(a)

		|	Or(Or(a, b), c) -> optop (Or(a, optop (Or(b, c))))
		|	Or(True, a) -> True
		|	Or(a, True) -> True
		|	Or(False, a) -> a
		|	Or(a, False) -> a
		|	Or(a,b) -> if a = b then a else p

		|	And(And(a, b), c) -> optop (And(a, optop (And(b, c))))
		|	And(True, a) -> a
		|	And(a, True) -> a
		|	And(False, a) -> False
		|	And(a, False) -> False
		|	And(a,b) -> if a = b then a else p

		|	If(True,a,b) -> a
		|	If(False,a,b) -> b
		|	If(Not(a),b,c) -> optop (If(a,c,b))
		|	If(a,b,c) -> if b = c then b else p

			(* turn operations into constants, where possible, and shift
					operators from the left to the right *)
		|	Min(Min(a,b),c) -> optop (Min(a,Min(b,c)))
		|	Min(NumCon(a), NumCon(b)) -> NumCon(min a b)
		|	Min(NumCon(a), Min(NumCon(b), c)) ->
				optop (Min(NumCon(min a b), c))
		|	Min(NumCon(a), Min(b, NumCon(c))) ->
				optop (Min(NumCon(min a c), b))

		|	Max(Max(a,b),c) -> optop (Max(a,Max(b,c)))
		|	Max(NumCon(a), NumCon(b)) -> NumCon(max a b)
		|	Max(NumCon(a), Max(NumCon(b), c)) ->
				optop (Max(NumCon(max a b), c))
		|	Max(NumCon(a), Max(b, NumCon(c))) ->
				optop (Max(NumCon(max a c), b))

		|	Sign(NumCon(a)) ->
				if a < 0.0 then NumCon(-1.0)
				else if a > 0.0 then NumCon(1.0)
				else NumCon(0.0)

		|	Abs(NumCon(a)) ->
				NumCon(if a < 0.0 then (~-. a) else a)

		|	Length(StrCon(a)) -> NumCon(float_of_int (String.length a))

		|	Left(StrCon(a), NumCon(b)) ->
				StrCon(Util.string_left a (int_of_float b))

		|	Right(StrCon(a), NumCon(b)) ->
				StrCon(Util.string_right a (int_of_float b))

		|	Mid(StrCon(a), NumCon(b), NumCon(c)) ->
				StrCon(Util.string_mid a (int_of_float b) (int_of_float c))

		|	Concat(StrCon(a), StrCon(b)) -> StrCon(a ^ b)

		|	_ -> p		(* cannot optimize any further - leave it as is *)
	in
	optop q;;


(*
 * Determine the data type of expressions, and wrap them appropriately
 *)

let rec typify p =
	match p with
		Screens(a) -> Screens(List.map typify a)
	|	ScreenDef(a,b) -> ScreenDef(a, typify b)
	|	Actions(a,b) ->
			(* force a to be typed before b *)
			let a2 = typify a in
			let b2 = typify b in
			Actions(a2, b2)
	|	Keep(a) -> Keep(typify a)
	|	Create(a,b) ->
			begin
				add_temp a;
				Create(a, typify b)
			end
	|	Replace(a,b,c) ->
			begin
				add_temp a;
				Replace(a, typify b, typify c)
			end
	|	Set(a,b) ->
			begin
				add_glob a;
				Set(a, typify b)
			end
	|	Print(a) -> Print(List.map typify a)
	|	AddScreen(a,b,c,d,e) ->
			begin
				add_temp (var_name "Total Score");
				add_temp (var_name "Screen Rank");
				add_temp (var_name "Pad");
				add_temp (var_name "Combo");
				add_temp (var_name "Max");
				p
			end
	|	Eq(a,b) -> Bool(Eq(typify a, typify b))
	|	Neq(a,b) -> Bool(Neq(typify a, typify b))
	|	Lt(a,b) -> Bool(Lt(typify a, typify b))
	|	Gt(a,b) -> Bool(Gt(typify a, typify b))
	|	Le(a,b) -> Bool(Le(typify a, typify b))
	|	Ge(a,b) -> Bool(Ge(typify a, typify b))
	|	Add(a,b) ->
			let ta = typify a in
			let tb = typify b in
			begin
				match (ta, tb) with
					(Date(x),Date(y)) ->
						raise (Syntax_error "cannot add two dates")
				|	(Date(x),y) -> Date(Add(ta,tb))
				|	(x,Date(y)) -> Date(Add(ta,tb))
				|	_ -> Num(Add(ta,tb))
			end
	|	Sub(a,b) ->
			let ta = typify a in
			let tb = typify b in
			begin
				match (ta, tb) with
					(Date(x),Date(y)) -> Num(Sub(ta,tb))
				|	(Date(x),y) -> Date(Sub(ta,tb))
				|	(x,Date(y)) ->
						raise (Syntax_error
								"cannot subtract a date from a number")
				|	_ -> Num(Sub(ta,tb))
			end
	|	Mult(a,b) -> Num(Mult(typify a, typify b))
	|	Div(a,b) -> Num(Div(typify a, typify b))
	|	Pow(a,b) -> Num(Pow(typify a, typify b))
	|	Neg(a) -> Num(Neg(typify a))
	|	Sym(a) ->
			(* delete to *HERE* and replace it with Any(p) to stop treating
				a symbol according to its field type in the DB *)
			begin
				try
					match symboltbl#get_db_type (mapname a) with
						Siarchive.Num -> Num(p)
					|	Siarchive.Date -> Date(p)
					|	Siarchive.Bool -> Bool(p)
					|	Siarchive.String -> Str(p)
					|	_ -> Any(p)
				with Not_found -> Any(p)
			end
			(* *HERE *)
	|	StrCon(a) -> Str(p)
	|	NumCon(a) -> Num(p)
	|	CurTime -> Date(CurTime)
	|	True -> Bool(True)
	|	False -> Bool(False)
	|	Not(a) -> Bool(Not(typify a))
	|	Or(a,b) -> Bool(Or(typify a, typify b))
	|	And(a,b) -> Bool(And(typify a, typify b))
	|	If(a,b,c) ->
			let wa = Bool(typify a) in
			let tb = typify b in
			let tc = typify c in
			begin
				match (tb, tc) with
					(Date(x),Date(y)) -> Date(If(wa,tb,tc))
				|	(Any(x),Any(y)) -> Any(If(wa,tb,tc))
				|	(Bool(x),Bool(y)) -> Bool(If(wa,tb,tc))
				|	(Any(x),y)|(x,Any(y)) -> Str(If(wa,tb,tc))
				|	(Str(x),y)|(x,Str(y)) -> Str(If(wa,tb,tc))
				|	(x,y) -> Num(If(wa,tb,tc))
			end
	|	Average(a) -> Num(p)
	|	Median(a) -> Num(p)
	|	Sum(a) -> Num(p)
	|	Count(a) -> Num(p)
	|	Min(a,b) -> Num(Min(typify a, typify b))
	|	Max(a,b) -> Num(Max(typify a, typify b))
	|	Sign(a) -> Num(Sign(typify a))
	|	Abs(a) -> Num(Abs(typify a))
	|	Length(a) -> Num(Length(typify a))
	|	Left(a,b) -> Str(Left(typify a, typify b))
	|	Right(a,b) -> Str(Right(typify a, typify b))
	|	Mid(a,b,c) -> Str(Mid(typify a, typify b, typify c))
	|	Match(a,b,c) -> Num(Match(typify a, b, c))
	|	Concat(a,b) -> Str(Concat(typify a, typify b))
	|	_ -> p;;
